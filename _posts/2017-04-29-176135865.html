---
layout: post
status: publish
published: true
title: Teeny tiny, fag-packety, parliamentary data models
author: Michael Smethurst
author_login: fantasticlife
wordpress_id: 176135865
wordpress_url: http://smethur.st/?p=176135865
date: '2017-05-04 17:30:00'
date_gmt: '2017-05-04 17:30:00'
tags: []
comments: []
---
		<h1>Teeny tiny, fag-packety, parliamentary data models</h1>
		<p>Late last year we published a <a href="https://github.com/ukparliament/domain-models/blob/master/Parliament/Parliament.pdf">first draft of a domain model for the UK Parliament</a>. There were two common reactions:</p>
		<ol>
			<li>Shit, that looks complicated</li>
			<li>Why are you biting all this off in one go? (see tweet from <a href="https://twitter.com/frankieroberto/status/774262003238072321">Frankie</a>)</li>
		</ol>
		<p>In fairness the whole thing did look like a misguided foray into accidental enterprise architecture. And probably gave the impression we were embarking on a journey to map 300 years of parliamentary procedure, before anyone even thought about business systems and data flows and whatever users might want of any of this. Which, honestly, was never what we were trying to do.</p>
		<p>We'd spent the previous few months trying to reverse engineer some version of sanity from <a href="http://www.data.parliament.uk/">data.parliament.uk</a> by looking at the instance data, and trying to work out what it was trying to describe. And we found that the data Parliament produced didn't really describe Parliament in a way that made sense to anyone (including those inside Parliament).</p>
		<p>The resulting pictures looked pretty much like the pictures of most organisations with any degree of history and complexity. Individual office functions had been digitised without any overarching plan for how the whole thing clipped together. If you squint long enough at the <a href="https://github.com/ukparliament/domain-models/blob/master/_legacy/DataDotParliament.pdf">picture of data.parliament</a>, you'll probably see blobs that look a bit like the table office or the journal office or the committee corridors but no real sense of how it hangs together.</p>
		<p>So the draft domain model wasn't intended to be a plan of everything with an implied instruction to build. It was just a first attempt at trying to explain (perhaps just to ourselves) how in theory the whole thing should hang together. Both <a href="https://twitter.com/silveroliver">Silver</a> and I were fairly new to parliamentary stuff (though <a href="https://twitter.com/bitten_">Anya</a> had served some time) so getting a rough map of the territory before picking off details felt a reasonable thing to do. It was never supposed to be complete or completable. Just an exercise in orientation.</p>
		<p>Since then we've been attempting to pick off tiny bits of the model and zoom in to some of the detail. The big picture (forgive me) has proved useful in giving a sense of where we are and which surrounding things we need to consider. So far we've tackled membership of houses, some library indexing things, a general sense of agency (people and groups of people), large scale parliamentary time periods, parliamentary elections and a few bits and bobs around online petitions. We're currently diving into select committees and hoping that the Commons and the Lords might possibly be able to agree what they mean by that. All this is probably less than five percent of everything. We like to think it's not slow progress but progress at the right pace (slow agile should be a thing). All of this needs feedback loops and if we get too far ahead of actual development and actual code we'll definitely descend into enterprise architecture vapour model hell. At the risk of repeating, all design starts when real data meets real content meets real users with real software and real connections on real devices. Until then, all design is vanity.</p>
		<p>With all that said, <a href="https://ukparliament.github.io/ontologies/">progress so far is published on GitHub</a>. Hopefully the models are fairly self-explanatory, but to understand how they stitch together you probably need to know a little about RDF. So...</p>
		
		<h2>A little about RDF (or <a href="#fag-packet-models">skip</a>)</h2>
		<p>I know <a href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> and <a href="https://en.wikipedia.org/wiki/Triplestore">triple stores</a> are not everyone's cup of tea (I'm never entirely sure they're mine). But they do have some properties that make designing small, self-contained data models easier to work with and combine.</p>
		<p>The basic building block of RDF is the triple. As the name might suggest, each triple is made of three parts: subject, predicate, object. Like:</p>
		<code>Jacob Rees-Mogg &gt; whippedTo &gt; Conservative Party</code>
		<p>The possible structures described by the RDF are defined in a thing called an ontology. Subjects and objects are defined in the usual class structure fashion: a Member of Parliament is a subclass of person. Predicates are defined by the set of classes of things they can point from (the domain of the predicate) and the set of classes of things they can point to (the range of the predicate). So the domain of the predicate whippedTo might be a Member of Parliament (or just a person) and the range might be a political party.</p>
		<p>RDF ontologies are a little like relational database schemas in so much as they're almost absolutely nothing like database schemas. The ontology does define the bounds of the possible, but unlike a database schema, the ontology doesn't act as a constraint on the data. It acts instead as another set of claims about the data. If the ontology were to define the whippedTo predicate as having a range of political party, and you used that predicate to point to a thing that was not a political party, you wouldn't get a validation error. Instead the thing that was not a political party would be inferred to be a political party because that's what the ontology says the range of the predicate is.</p>
		<p>No matter how well you model your ontology, if the instance data isn't carefully loaded then the whole business of RDF data gathering claims from the ontology can have all kinds of unexpected and fairly disastrous side effects. One misused predicate and all your towns become administrative areas, all your administrative areas become towns; all your dogs become cats, all your cats become dogs; all your living people become dead, and all your dead people come back to life.</p>
		<p>But it does have one advantage in that you don't have to specify all the potential relationships between classes in the ontology. Just by using a predicate with a range of X, the thing you use the predicate on automatically gets typed as being of class X. In the Parliament work to date we have a tiny model for <a href="https://ukparliament.github.io/ontologies/contact-point/contact-point-ontology.html">contact points</a>. It defines phone numbers, fax numbers, email addresses, contact form URLs, postal addresses etc. It also defines a predicate called <a href="https://ukparliament.github.io/ontologies/contact-point/contact-point-ontology.html#d4e102">hasContactPoint</a>, with a domain of <a href="https://ukparliament.github.io/ontologies/contact-point/contact-point-ontology.html#d4e305">ContactableThing</a> and a range of <a href="https://ukparliament.github.io/ontologies/contact-point/contact-point-ontology.html#d4e294">ContactPoint</a>. We can choose to use this predicate on anything so we might have instance data representing Jacob Rees-Mogg who's declared to be in the class of People. We don't have to define People as being a subclass of ContactableThings, we can just use the predicate hasContactPoint and Jacob immediately becomes both a Person and a ContactableThing. So <em>class structure is emergent from use</em> (which would also make a good tshirt if anyone's printing).</p>
		
		
		<h2 id="fag-packet-models">Some advantages of fag packet data models</h2>
		<p>There are a whole bunch of reasons you might want to keep data models small and loosely coupled:</p>
		<ol>
			<li>Proper domain driven design people would talk about bounded contexts. There's <a href="https://martinfowler.com/bliki/BoundedContext.html">better writing than this by Martin Fowler on why you need bounded contexts</a> particularly in complex organisations, particularly where language is slippery outside of context (looking at you, Parliament).</li>
			<li>Chunked up data models make concentrating on the problem area easier. You can close your mind to the bits that aren't pertinent whilst still maintaining a bigger picture.</li>
			<li>Tiny data models are easier to work with. Or at least easier to switch between contexts. You can be working in one area and suddenly realise you have to add something to a separate model. Opening up a massive <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model">ERD</a> takes time to orientate. Opening up something the size of a napkin means you can digest almost at a glance, make the change you need to make and get out.</li>
			<li>Tiny data models are easier to share because they're easier for the people you're sharing with to understand. Recently we did some work on a <a href="https://ukparliament.github.io/ontologies/time-period/time-period-ontology.html">parliamentary time period ontology</a> which we pushed to GitHub and tweeted. Which got retweeted by <a href="https://twitter.com/psychemedia">Tony</a> and picked up by <a href="https://twitter.com/cgutteridge">Chris</a> who spotted almost immediately that we'd defined the reign of a monarch to be a time period (when it's probably more of an event). Chris replied and we fixed it. Similar with <a href="https://twitter.com/GefionT">Gefion</a>'s comments on our <a href="https://ukparliament.github.io/ontologies/election/election-ontology.html">election model</a>. She pointed out that it wouldn't quite work outside the UK which wouldn't really help with our standardisation efforts. We took a second look and realised that it wouldn't actually work for the UK either for many of the same reasons. So that was good to fix. Would these things have been spotted and corrected as easily if they were fragments of models floating in a soup of everything else? Possibly, but probably not so quickly.</li>
			<li>Tiny data models are <a href="http://cognitive-edge.com/blog/the-table-napkin-test/">easy to draw and redraw and talk over</a>. Whether on a whiteboard or a napkin or an actual fag packet. You can quite quickly sketch the bits you're interested in, introduce new people to it, talk it through and correct.</li>
			<li>Tiny, agile, loosely coupled data models make it easier for multiple small, agile, loosely coupled teams to work in roughly the same area without treading on each other's toes</li>
			<li>Unproved for now but at least in theory, tiny data models help with standardisation. It's unlikely all legislatures will agree on all things, but splitting the data model into bounded contexts makes it easier to pick off bits you can agree on and bits that are specific to Parliament.</li>
			<li>As someone once said (possibly me), if it won't fit on a fag packet, it probably can't be built.</li>
		</ol>
		<p>Anyway, the <a href="https://ukparliament.github.io/ontologies/">data models so far are here</a>. We still need to write some notes to explain a few of the design decisions we've made. Hopefully we'll do that soon. Comments, pull requests, conversations welcome as ever.</p>
				